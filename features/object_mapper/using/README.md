## Using mappers

Once the class entities are correctly defined, the driver mapper provides a class `Mapper`.

### Mappers

Each mapped class will be managed by a dedicated `Mapper` object. `Mapper` objects are thread-safe so can be shared across multiple threads.

A `Mapper` class is instantiated by/through a class [MappingManager]. This class will create `Mapper`s and store all information needed to make mapper objects work. Hence, it requires a [Session] object initialized and successfully connected to a *Cassandra* cluster.

In the following example we consider the class `User` as defined in the [previous section](../creating/#creating-a-table-entity).

```java
MappingManager manager = new MappingManager(session);
Mapper<User> mapper = manager.mapper(User.class);
```

`Mapper`s are cached in the manager, so calling `manager#mapper` more than once for the same class will return the previously generated mapper.

Constructor `MappingManager(session)` will initialize the `session` if not previously done. If your application requires the `session` not to be initialized at this moment, use constructor `MappingManager(session, protocolVersion)`.

[MappingManager]:http://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/mapping/MappingManager.html
[Session]:http://docs.datastax.com/en/drivers/java/2.1/com/datastax/driver/core/Session.html

***

#### Basic CRUD operations

`Mapper` object provides all methods required to persist and retrieve data from the database, and maps it in Java objects.

To save an object created within the client program, use `Mapper#save` :

```java
UUID userId = ...;
User u = new User(userId, "Doe", new Address("street", 01000));
mapper.save(u);
```

--------------

To retrieve an object, use `Mapper#get` :

```java
UUID userId = ...;
User u = mapper.get(userId);
```

The argument(s) in the get method must be composed of the exact same partition keys defined in the class entity, and in the database. The `get()` method accepts `Object...` arguments so Java types can be used directly. If the types or number of arguments don't match the definition in the Cassandra table, an exception will be thrown.

--------------

To delete a row in a table, use `Mapper#delete`. This method support deleting a row given either its primary keys, or an object matching the row aimed for deletion :

```java
UUID userId = ...;
mapper.delete(userId);
mapper.delete(u);
```

--------------

All these CRUD operations are synchronous, but the `Mapper` provides their asynchronous equivalents :
  
```java
ListenableFuture<Void> saveFuture = mapper.saveAsync(u);
ListenableFuture<User> userFuture = mapper.getAsync(userId);
ListenableFuture<Void> deleteFuture = mapper.deleteAsync(userId);
```

***

#### Generating queries from mapper

Instead of performing operations itself, the `Mapper` gives the possibility to get the query to use for an operation. Then, with this returned query generated with the mapper, the user can set options or make a different processing on it :

- `Mapper.saveQuery(entity)` : returns a statement generated by the mapper to save `entity` into the database.
- `Mapper.getQuery(userId)` : returns a statement to select a row in the database, selected on the given `userId`, and matching the mapped object structure.
- `Mapper.deleteQuery(userID)` : returns a statement delete a row in the database given the `userId` provided. This method can also accept a mapped object instance.

***

#### Manual mapping

In case the client needs to execute specific queries with specific options, the `Mapper` object provides a `Mapper#map` method. This method takes a `ResultSet` in argument, and will map result rows into a result collection of mapped objects.

Extra columns in the executed query will be ignored. About fields in the mapped object that are not in the `ResultSet`'s rows, setters won't be called to set the field so their value will be the value after invocation of the default's class constructor.

Here is an example with previously defined tables and mapped entities : 

```java
ResultSet results = session.execute("SELECT * FROM user");
Result<User> users = mapper.map(results);
for (User u : users){
    System.out.println("User : " + u.getUserId());
}
```

`Result` class is similar to `ResultSet` but for a given mapped class. It provides methods `one()`, `all()`, `iterator()`, `getExecutionInfo()` and `isExhausted()`. Be careful, the `ResultSet` given in parameter will be stored in the `Result` class. This means that consumed rows in `ResultSet` will be considered consumed in the `Result` also.

Because of previous warnings (`ResultSet` consumption, and empty fields), we recommend trying to prevent the use this `map()` method, and either stick to [CRUD operations](#basic-crud-operations), or use [queries generated by the mapper](#generating-queries-from-mapper), or use [Accessors](#accessors).

***

#### UDT Mapper

A UDT will be automatically mapped when it is part of a table-level class (as demonstrated by `User#address` in our example). However, there might be cases where it is useful to get back a UDTValue from a non-mapper query and map it to its domain class. It is possible to get a UDTMapper from the MappingManager:

```java
UDTMapper<Address> addressMapper = manager.getUDTMapper(Address.class);
Address address = addressMapper.map(udtValue);
```

### Accessors

The object mapper provides ways to easily execute customized queries and bind them into mapped objects, these are called `Accessor`s. Accessors define functions written by the client to perform an operation in the database, with potential parameters, and maps results into objects. `@Query` contains the query to be executed in Cassandra and is followed by a method declaration.

Here is an example with the previously defined `User` class :

```java
@Accessor
public interface UserAccessor {
    @Query("SELECT * FROM user")
    Result<User> getAll();
}
```

The return type is important here, the results of the query will be automatically either mapped in a single object or in a collection of objects.

The `MappingManager` can then process this class and generate an implementation :

```java
UserAccessor userAccessor = manager.createAccessor(UserAccessor.class);
User user = userAccessor.getOne(uuid);
```

Like mappers, accessors are cached at the manager level and thus, are thread-safe/sharable.

--------------

Named or unnamed bind markers can be used in a `@Query`, when using a bind marker in a `@Query`, the corresponding accessor's method can accept parameters. Parameters are specified with `@Param` annotation before each parameter of the method : 

```java
@Accessor
public interface UserAccessor {
    @Query("SELECT * FROM user WHERE user_id=?")
    User getOne(UUID userId);
}

@Accessor
public interface FooAccessor {
    @Query("insert into foo (userId, name) values (:u, :n)")
    ResultSet insert(@Param("u") UUID userId, @Param("n") String name);
}

@Accessor
public interface FooBindMarkerAccessor {
    @Query("insert into foo (k, v) values (?, ?)")
    ResultSet insert(@Param("u") UUID userId, @Param("n") String name);
}
```

--------------

A method parameter can be preceded by `@Enumerated` instead of `@Param`, this to state that the parameter is a Java enumeration. As for enumeration fields, the `EnumType` has to be specified.

The following example acts on two tables : `user(key int primary key, gender int)` and `user_str(key int primary key, gender text)`.

```java
enum Enum {
    MALE, FEMALE
}

@Table(name = "user")
public static class User {
    @PartitionKey
    private int key;

    @Enumerated(EnumType.ORDINAL)
    private Enum gender;
    
    // ... constructors / getters / setters
}

@Table(name = "user_str")
public static class UserStr {
    @PartitionKey
    private int key;

    private Enum gender;
    
    // ... constructors / getters / setters
}

@Accessor
public interface UserAccessor {
    @Query("insert into user (key, gender) values (?,?)")
    ResultSet addUser(int key, @Enumerated(EnumType.ORDINAL) Enum value);
    
    @Query("insert into user_str (key, gender) values (?,?)")
    ResultSet addUserStr(int key, @Enumerated(EnumType.STRING) Enum value);
}
```

--------------

To specify whether the queries in a `Accessor` need to be executed asynchronously, the return type has to be set as a `ListenableFuture` :

```java
@Query("SELECT * FROM user")
public ListenableFuture<Result<User>> getAllAsync();
```

--------------

It is possible to customize query parameters to include in a `Accessor` query with the annotation `@QueryParameters`. Then, options like *consistency level*, *fetchsize* or *tracing* are settable :
  
```java
@Query("SELECT * FROM ks.users")
@QueryParameters(consistency="QUORUM")
public ListenableFuture<Result<User>> getAllAsync();
```

### Options

The mapper provides high level operations like `save` or `get`. It is possible to add specific options to queries by [gathering the generated statement](#generating-queries-from-mapper), setting options and executing them manually. But this is not the most convenient way to do it, a more convenient way is to use the `Mapper.Option` class.`Option`s can be used as an argument of a CRUD operation (e.g. `Mapper#save`) or when generating a query from the mapper (e.g. `Mapper#saveQuery`).

`Option`s are classes defined in the mapper that can be used in a CRUD operation. Some options are valid for some operations, some not. Here is a descriptive list of currently available options : 
 
- `Ttl` : add a time-to-live value for the operation.
- `Timestamp` : add a timestamp value for the operation.
- `ConsistencyLevel` : specify a consistency level.
- `Tracing` : set tracing flag for the query.
- `SaveNullFields` : if set to true, fields with value `null` in an instance that is to be persisted, will be explicitly written as `null` in the query. If set to false, fields with null value won't be included in the write query. Depending on the choice of this value persisting an object can either create tombstones in the database (value is `true`) or can lead to certain inconsistency (value is `false`)

The matrix of compatible options and operations : 

  Option  | save/saveQuery | get/getQuery | delete/deleteQuery
:--------:|:--------------:|:------------:|:------------------:
Ttl | yes | no | no
Timestamp | yes | no | yes
ConsistencyLevel | yes | yes | yes
Tracing | yes | yes | yes
SaveNullFields | yes | no | no

--------------

Static functions within the `Mapper` class allow creating `Option` classes :

```java
UUID userId = ....;
Option opt = Option.ttl(42);
mapper.save(new User(userId, "helloworld"), Option.timestamp(123456L), Option.tracing(true), opt);
```

Note that there is a conflict with [defining consistency on a table entity](../creating/#creating-a-table-entity). Consistency levels defined with `@Table` annotation will be ignored if a consistency level is set as a `Option`.

--------------

It is possible to set default options for a `Mapper` instance : 
 
```java
mapper.setDefaultGetOption(Option.tracing(true), Option.consistencyLevel(ConsistencyLevel.QUORUM);
mapper.setDefaultSaveOption(Option.saveNullFields(false));
mapper.setDefaultDeleteOption(Option.timstamp(45L);
```

To cancel default set options there are `Mapper.resetDefault*OPERATION*Option`.